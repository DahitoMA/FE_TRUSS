#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import division
import os
from InitTest import *
import Truss
from Truss.ClampedBeam import *

folder = os.path.dirname(__file__) + '/' # Working folder
folder = folder.replace("\\","/")
n = 2*nEls # Dimension of the problem

###################### !!! TO MODIFY ACCORDING TO THE PROBLEM !!!
pop_size = nEls # Population size
randpop = False # Initial population random (True) or generated by the solver (False)
it_max = 2002 #1000 # Maximum number of iterations
nb_runs = 20 # Number of runs/optimizations
savingpath = folder+'Fem_case'+str(case)+'/titan_mag_alu_steel/'+type_mat+'/'+func+'/'+solver+'/'
if data_save and not os.path.exists(savingpath):
    os.makedirs(savingpath)
######################

print('FE case '+str(case)+', '+opt_pb+' with '+solver+', '+str(type_mat)+ ', '+str(nb_runs)+' runs')


def penalize(obj_func, Youngs, pop, a=1e5, f0=None, type_mat='Real_type', Categ=[1,2,3,4]):
    npop = len(pop) # pop size
    fvalues = []
    feas_fvalues = [] # fvalues of feasible solutions
    infeas_idx = [] # indices of infeasible solutions in the population
    C = np.zeros(npop) # constraint violations            
    for k in range(npop):
        indiv = pop[k]
        if type_mat in ('Cycle_type', 'Categ_type'):
            mat_nb = copy.copy(indiv[0:nEls])
            Es = nEls*[0]
            for el in range(nEls):
                if mat_nb[el]%4 == Categ[0]%4: #titan
                    Es[el] = Youngs[0]
                elif mat_nb[el]%4 == Categ[1]%4: #mag
                    Es[el] = Youngs[1]
                elif mat_nb[el]%4 == Categ[2]%4: #steel
                    Es[el] = Youngs[2]
                elif mat_nb[el]%4 == Categ[3]%4: #alu
                    Es[el] = Youngs[3]
        elif type_mat in ('Real_type', 'Int_type'):
            Es = indiv[0:nEls]   
        elif type_mat == 'Int_type2':
            Es = indiv[0:nEls]*1e6
        fvalues.append(obj_func(pop[k]))
        U, F = FE.solveq(case,Fa,Es, alphas,
                         indiv[nEls:n],gcor, nEls,nN, connect)
        if case == 1:
            cstr = abs(U[5]) - abs(Uy3max)
            if cstr <= 0:
                feas_fvalues.append(fvalues[k])
                C[k] = 0
            else:
                infeas_idx.append(k)
                C[k] = cstr
        if case == 2:
            cstr = abs(U[8]) - abs(Ux5max)
            if cstr <= 0:
                feas_fvalues.append(fvalues[k])
                C[k] = 0
            else:
                infeas_idx.append(k)
                C[k] = cstr
    pen_fvalues = copy.copy(fvalues)
    if len(feas_fvalues) != 0:
        offset = np.percentile(feas_fvalues, 25) #1st quartile
    else:
        offset = np.median(fvalues)
            
    if f0 == None:
        for k in range(npop):
            pen_fvalues[k] = fvalues[k] + a * (C[k] * 1e2)**2
    else:
        for k in range(npop):
            if case == 1:
                pen_fvalues[k] = fvalues[k] / f0 + C[k] / abs(Uy3max)
            elif case == 2:
                pen_fvalues[k] = fvalues[k] / f0 + C[k] / abs(Ux5max)
    idx = np.where(pen_fvalues==min(pen_fvalues))[0][0]       
    fminpen = fvalues[idx] # real fvalue of the penalization minimizer
    Cminpen = C[idx] # corresponding constraint violation of fminpen
    
    return pen_fvalues, C, fminpen, Cminpen

lb = np.zeros(n)
ub = np.zeros(n)
lb[nEls:n] = thick_lb #0.01
ub[nEls:n] = thick_ub #0.05
if type_mat == 'Categ_type':
    lb[0:nEls] = 1
    ub[0:nEls] = 4
elif type_mat == 'Cycle_type':
    lb[0:nEls] = -np.inf
    ub[0:nEls] = np.inf
else:
    lb[0:nEls] = Mag
    ub[0:nEls] = Steel
    
opts = {'bounds': [lb,ub], 'CMA_stds': (ub-lb)/4, 'popsize': pop_size, 
        'maxiter': it_max, 'tolfun': 1e-11}
if cycle_bool:
    opts['integer_variables'] = list(range(nEls))
#    opts.pop('bounds')
    lb[0:nEls] = nEls*[1] #nEls*[-1e6] # -np.inf or 0 or 1
    ub[0:nEls] = nEls*[4] #nEls*[1e6] # 5 or np.inf
    opts['bounds'] = [lb,ub]
    cma_stds = [1]*nEls #[0.75]*nEls
    for i in range(nEls):
        cma_stds.append((ub[nEls+i] - lb[nEls+i])/4)
    opts['CMA_stds'] = cma_stds  # (ub-lb)/4

" Define target values "
maxpower = math.floor(math.log10(maxv-target_min)) # power of the max possible value
last = 10**maxpower 
# range of magnitude between max possible value and target_min
mag_range = int(maxpower-math.floor(math.log10(target_precision)))
target_values = list()
for k in range(mag_range):
    nextv = last * 1e-1
    if k == 0 and maxpower != math.floor(math.log10(target_min)):
        values = np.logspace(maxpower,maxpower-1,num=target_per_mag+1)
        for j in range(len(values)-1):
            target_values.append(values[j])
    else: 
        values = np.linspace(last, nextv, num=target_per_mag+1)
        if k == mag_range-1:
            for j in range(len(values)):
                target_values.append(values[j])
        else:
            for j in range(len(values)-1):
                target_values.append(values[j])
    last = nextv
targets = copy.copy(target_values)
nb_of_targets = len(target_values)

best = np.zeros((n,nb_runs)) # best individual for every run
MINFVALUES = {} # dictionary with the real fvalues of the penalization minimizer through all previous generations, for each global iteration
BestFVALUES = {} # Dictionnary of the best real fvalues ranked from minimal constraint violation through all previous generations
COFMIN = {} # dictionnary of the constraint violations of MINFVALUES
COFBest = {} # dictionnary of the constraint violations of BestFVALUES
RATES = {} # dictionnary of rates of reached targets
COLOR = ['blue', 'orange', 'green', 'red', 'purple', 'brown', 'pink', 'gray', 
         'olive', 'cyan', 'black', 'gold', 'yellowgreen', 'darkblue', 'crimson',
         'pink', 'deeppink', 'darkcyan', 'olivedrab', 'tan', 'orchid']
for it in range(nb_runs): # launch nb_runs times the algorithm
    print('\nRun '+str(it+1)+'\n')
    " Define target values "
    target_values = copy.copy(targets)
    target_nb = 0 # number of reached target values
    reached_targets = []
    " Initial population "
    if randpop:
        # Give pop_size initial points chosen uniformly as random
        popinit = list()
        for _ in range(pop_size):
            Es = np.zeros(nEls)
            Thicknesses = np.zeros(nEls)
            for k in range(nEls):
                Es[k] = random.choice([Mag, Titan, Alu, Steel])
                Thicknesses[k] = random.uniform(thick_lb,thick_ub)
            popinit.append(np.concatenate((Es,Thicknesses)))
        x0 = popinit[0]
        # f0 = objectives(x0)
        sigma0 = 1
        es = cma.CMAEvolutionStrategy(x0, sigma0, opts)    
        es.pop_injection_solutions = copy.copy(popinit)
        es.ask()
        pop = copy.copy(popinit)  
    else:    
        Thicknesses = np.zeros(nEls)
        Es = np.zeros(nEls)
        for j in range(nEls):
            Es[j] = random.choice([Mag, Titan, Alu, Steel])
            Thicknesses[j] = random.uniform(thick_lb,thick_ub)
        x0 = np.concatenate((Es, Thicknesses))
        sigma0 = 1
        es = cma.CMAEvolutionStrategy(x0, sigma0, opts)    
        pop = es.ask() # Initial population generated by CMA-ES
        if cycle_bool:
            for indiv in pop:
                for o in range(nEls):
                    indiv[o] = round(indiv[o])

    MINFVALUES[it+1] = [] 
    BestFVALUES[it+1] = []
    COFMIN[it+1] = [] 
    COFBest[it+1] = []
    RATES[it+1] = []
    # Initial values
    pen_fvalues, C, fminpen, Cminpen = penalize(object_func, Youngs, pop, a=1e5, f0=None,
                                                type_mat=type_mat, Categ=[1,2,3,4])
    COFMIN[it+1].append(Cminpen)
    COFBest[it+1].append(Cminpen)
    MINFVALUES[it+1].append(fminpen)
    BestFVALUES[it+1].append(fminpen)
    if COFMIN[it+1][-1] == 0:
        # number of reached target values
        tmp = [target_values[i] for i in range(len(target_values)) if target_values[i] >= (MINFVALUES[it+1][-1]-target_min)]
        target_nb += len(tmp)
        RATES[it+1].append(len(tmp)/nb_of_targets)
        if tmp != []:
            for el in range(len(tmp)):
                reached_targets.append(tmp[el])
                target_values.pop(0)
    else:
        RATES[it+1].append(0)
    es.tell(pop, pen_fvalues)
    es.logger.add()
    es.disp()
#    while not es.stop():
    for k in range(it_max):
        pop = es.ask()
        if cycle_bool:
            for indiv in pop:
                for o in range(nEls):
                    indiv[o] = round(indiv[o])
        pen_fvalues, C, fminpen, Cminpen = penalize(object_func, Youngs, pop, a=1e5,
                                                    f0=None, type_mat=type_mat,
                                                    Categ=[1,2,3,4])
        if Cminpen < COFBest[it+1][-1]:
            BestFVALUES[it+1].append(fminpen)
            COFBest[it+1].append(Cminpen)
        elif Cminpen ==  COFBest[it+1][-1] and fminpen < BestFVALUES[it+1][-1]:
            BestFVALUES[it+1].append(fminpen)
            COFBest[it+1].append(Cminpen)
        else:
            BestFVALUES[it+1].append(BestFVALUES[it+1][-1])
            COFBest[it+1].append(COFBest[it+1][-1])
        m = min(np.append(MINFVALUES[it+1], fminpen))
        if m == fminpen:
            COFMIN[it+1].append(Cminpen)
        else:
            COFMIN[it+1].append(COFMIN[it+1][-1])
        MINFVALUES[it+1].append(m)
        if COFMIN[it+1][-1] == 0:
            # number of reached target values
            tmp = [target_values[i] for i in range(len(target_values)) if target_values[i] >= (MINFVALUES[it+1][-1]-target_min)]
            target_nb += len(tmp)
            if tmp != []:
                RATES[it+1].append(target_nb/nb_of_targets)
                for el in range(len(tmp)):
                    reached_targets.append(tmp[el])
            else:
                if len(RATES[it+1]) == 0:
                    RATES[it+1].append(0)
                else:
                    RATES[it+1].append(RATES[it+1][-1])
            for j in range(len(tmp)):
                target_values.pop(0)
        else:
            if len(RATES[it+1]) == 0:
                RATES[it+1].append(0)
            else:
                RATES[it+1].append(RATES[it+1][-1])
        es.tell(pop, pen_fvalues)
        es.logger.add()
        es.disp()
    # save best individual
    for h in range(n):
        best[h,it] = es.result[0][h]


    " Save best individuals for every run "
    plt.figure()        
    print('Solution of run ' + str(it+1))
    if type_mat in ('Cycle_mat', 'Categ_type'):
        cycl = 'True'
    else:
        cycl = 'False'
    FE.displaymaterials(best[:,it], Titan, Mag, Steel, Alu, connect, gcor, cycle=cycle_bool)
    if data_save:
        plt.savefig(savingpath +'case'+str(case)+'_run'+str(it+1)
                    +'_mesh_solution')    
    if data_save:
        np.savetxt(savingpath+'case'+str(case)+'_nondominated_run'
                  +str(it+1)+'.txt', best[:,it])


" Plot evolution of min fvalues through all generations and corresponding constraint violations "    
plt.figure()
plt.title(solver+', '+str(opt_pb)+', case '+str(case)+ ', '+str(type_mat)+', best fvalues')
plt.xlabel('Function evaluations')
plt.ylabel('Best fvalues')
#for k in range(len(MINFVALUES)):
#    for idx in range(len(MINFVALUES[k+1])):
#        feval = np.linspace(pop_size,len(MINFVALUES[k+1])*pop_size,num=len(MINFVALUES[k+1]))
#        plt.loglog(feval, MINFVALUES[k+1], color=COLOR[k])
for k in range(len(BestFVALUES)):
    for idx in range(len(BestFVALUES[k+1])):
        feval = np.linspace(pop_size,len(BestFVALUES[k+1])*pop_size,num=len(BestFVALUES[k+1]))
        plt.loglog(feval, BestFVALUES[k+1], color=COLOR[k])
if data_save:
    plt.savefig(savingpath+'overall_best_fvalues_'+str(nb_runs)+'runs')
        
plt.figure()
plt.title(solver+', '+str(opt_pb)+', case '+str(case)+ ', '+str(type_mat)+', constraint violations')
plt.xlabel('Function evaluations')
plt.ylabel('Constraint violations')
for k in range(len(COFMIN)):
    for idx in range(len(COFMIN[k+1])):
        feval = np.linspace(pop_size,len(COFMIN[k+1])*pop_size,num=len(COFMIN[k+1]))
        plt.loglog(feval, COFMIN[k+1], color=COLOR[k])
    if data_save:
        plt.savefig(savingpath+'overall_constr_viol_'+str(nb_runs)+'runs')
    maxlines = max(len(x) for x in (BestFVALUES[k+1] for k in range(nb_runs)))
    " Convert doctionnaries to arrays "
    matMINFVALUES = np.zeros((maxlines, nb_runs)) 
    matBestFVALUES = np.zeros((maxlines, nb_runs))
    matCOFMIN = np.zeros((maxlines, nb_runs)) 
    matCOFBest = np.zeros((maxlines, nb_runs))
    matRATES = np.zeros((maxlines, nb_runs))
    " Write arrays in txt files "
    for k in range(nb_runs):
        matMINFVALUES[0:len(MINFVALUES[k+1]),k] = copy.copy(MINFVALUES[k+1])
        matBestFVALUES[0:len(BestFVALUES[k+1]),k] = copy.copy(BestFVALUES[k+1])
        matCOFMIN[0:len(COFMIN[k+1]),k] = copy.copy(COFMIN[k+1])
        matCOFBest[0:len(COFBest[k+1]),k] = copy.copy(COFBest[k+1])
        matRATES[0:len(RATES[k+1]),k] = copy.copy(RATES[k+1])
        for j in range(len(RATES[k+1]),maxlines):
            matRATES[j,k] = matRATES[len(RATES[k+1])-1,k]
            
    with open(folder+'/Fem_case'+str(case)+'/titan_mag_alu_steel/'+type_mat+'/'
              +func+'/'+solver+'/'+'overall_best_fvalues_'+str(nb_runs)+'runs.txt', 'w+') as in_file:
        for k in range(matBestFVALUES.shape[0]):
            for i in range(nb_runs):
                in_file.write(str(matBestFVALUES[k,i])+' ')
            in_file.write('\n')
    with open(folder+'/Fem_case'+str(case)+'/titan_mag_alu_steel/'+type_mat+'/'
              +func+'/'+solver+'/'+'overall_best_constr_viol_'+str(nb_runs)+'runs.txt', 'w+') as in_file:
        for k in range(matCOFBest.shape[0]):
            for i in range(nb_runs):
                in_file.write(str(matCOFBest[k,i])+' ')
            in_file.write('\n')  
    with open(folder+'/Fem_case'+str(case)+'/titan_mag_alu_steel/'+type_mat+'/'
              +func+'/'+solver+'/'+'overall_best_fminpen_'+str(nb_runs)+'runs.txt', 'w+') as in_file:
        for k in range(matMINFVALUES.shape[0]):
            for i in range(nb_runs):
                in_file.write(str(matMINFVALUES[k,i])+' ')
            in_file.write('\n')
    with open(folder+'/Fem_case'+str(case)+'/titan_mag_alu_steel/'+type_mat+'/'
              +func+'/'+solver+'/'+'overall_constr_violOfFminpen_'+str(nb_runs)+'runs.txt', 'w+') as in_file:
        for k in range(matCOFMIN.shape[0]):
            for i in range(nb_runs):
                in_file.write(str(matCOFMIN[k,i])+' ')
            in_file.write('\n')           
    with open(folder+'/Fem_case'+str(case)+'/titan_mag_alu_steel/'+type_mat+'/'
              +func+'/'+solver+'/'+'target_rates_'+str(nb_runs)+'runs.txt', 'w+') as in_file:
        for k in range(matRATES.shape[0]):
            for i in range(nb_runs):
                in_file.write(str(matRATES[k,i])+' ')
            in_file.write('\n')

    maxlines = [] # max number of lines of COFMIN
    for k in range(nb_runs):
        maxlines.append(len(COFMIN[k+1]))
    maxl = max(maxlines)
    with open(folder+'/Fem_case'+str(case)+'/titan_mag_alu_steel/'+type_mat+'/'
              +func+'/'+solver+'/'+'dict_overall_constr_viol_'+str(nb_runs)
              +'runs.txt', 'w+') as in_file:
        for i in range(maxl):
            for k in range(nb_runs):
                if i < maxlines[k]:
                    in_file.write(str(COFMIN[k+1][i])+' ')
                else:
                    in_file.write('None')
            in_file.write('\n')
    
plt.figure()
plt.title(solver+', '+str(opt_pb)+', case '+str(case)+', '+str(type_mat)+', ECDF')
plt.xlabel('Function evaluations')
plt.ylabel('Fraction of targets reached')
for k in range(len(RATES)):
    for idx in range(len(RATES[k+1])):
        feval = np.linspace(pop_size,len(RATES[k+1])*pop_size,num=len(RATES[k+1]))
        plt.plot(feval, RATES[k+1], color=COLOR[k])
if data_save:
    plt.savefig(savingpath+'ECDF_'+str(nb_runs)+'runs')
    with open(folder+'/Fem_case'+str(case)+'/titan_mag_alu_steel/'+type_mat
              +'/'+func+'/'+solver+'/'+'target_rates_'+str(nb_runs)+'runs.txt', 'w+') as in_file:
        for k in range(it_max+1):
            for i in range(1,nb_runs+1):
                in_file.write(str(RATES[i][k])+' ')
            in_file.write('\n')
    # save best solution of all runs
    minbest = min(matBestFVALUES[-1,:])
    idx = np.where(matBestFVALUES[-1,:] == minbest)[0][0]
    bestind = best[:,idx] # best individual of all runs
    np.savetxt(savingpath+'best_indiv_'+str(nb_runs)+'runs.txt', bestind)
    